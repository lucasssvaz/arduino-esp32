{
  "title": "11 errors, 43 pass in 1h 45m 59s",
  "summary": "186 files  186 suites   1h 45m 59s ⏱️\n 54 tests  43 ✅ 0 💤 0 ❌ 11 🔥\n454 runs  438 ✅ 0 💤 0 ❌ 16 🔥\n\nResults for commit edd79b3f.\n",
  "conclusion": "failure",
  "stats": {
    "files": 186,
    "errors": [],
    "suites": 186,
    "duration": 6359,
    "suite_details": [
      {
        "name": "validation_wokwi_esp32s3_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_uart0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_uart0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_uart0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_touch0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32h2_uart0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32c3_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_wifi2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32_timer0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_psram0",
        "tests": 8,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_i2c_master0",
        "tests": 6,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_i2c_master0",
        "tests": 6,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_touch0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_wifi1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32s3_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_wifi",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32c3_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_uart0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_timer0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_uart0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_linpack_double0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c6_wifi",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32s2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_wifi1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32c3_uart0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_wifi1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32h2_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_uart0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_nvs3",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_uart0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_touch0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_democfg0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32h2_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s3_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32p4_gpio0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_hardware_esp32p4_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_uart0",
        "tests": 11,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "performance_hardware_esp32c3_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_wifi1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32h2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32c6_i2c_master0",
        "tests": 7,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_psram0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_nvs0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_nvs2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_wifi1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32p4_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s3_wifi2",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_coremark0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_uart0",
        "tests": 10,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32c3_periman0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32h2_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_psram0",
        "tests": 8,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s3_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32s2_timer0",
        "tests": 4,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_linpack_float0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_democfg1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_hello_world0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c3_fibonacci0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c3_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32c6_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 1
      },
      {
        "name": "validation_wokwi_esp32s3_wifi1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32c6_wifi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32s2_superpi0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_wokwi_esp32s2_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32_nvs1",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32h2_ramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32s2_unity0",
        "tests": 2,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "performance_hardware_esp32p4_psramspeed0",
        "tests": 1,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      },
      {
        "name": "validation_hardware_esp32p4_touch0",
        "tests": 3,
        "skipped": 0,
        "failures": 0,
        "errors": 0
      }
    ],
    "tests": 54,
    "tests_succ": 43,
    "tests_skip": 0,
    "tests_fail": 0,
    "tests_error": 11,
    "runs": 454,
    "runs_succ": 438,
    "runs_skip": 0,
    "runs_fail": 0,
    "runs_error": 16,
    "commit": "edd79b3f4417966f12b4a5b11a4af83df623068b"
  },
  "annotations": [
    {
      "path": "performance.linpack_double.test_linpack_double",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/performance/linpack_double/esp32c6/linpack_double.xml [took 0s]",
      "title": "1 out of 7 runs with error: test_linpack_double (performance.linpack_double.test_linpack_double)",
      "raw_details": "failed on setup with \"esptool.util.FatalError: Could not open /dev/ttyUSB28, the port is busy or doesn't exist.\n([Errno 6] could not open port /dev/ttyUSB28: [Errno 6] No such device or address: '/dev/ttyUSB28')\"\nself = Serial<id=0x7f797cda0340, open=False>(port='/dev/ttyUSB28', baudrate=9600, bytesize=8, parity='N', stopbits=1, timeout=None, xonxoff=False, rtscts=False, dsrdtr=False)\n\n    def open(self):\n        \"\"\"\\\n        Open port with current settings. This may throw a SerialException\n        if the port cannot be opened.\"\"\"\n        if self._port is None:\n            raise SerialException(\"Port must be configured before it can be used.\")\n        if self.is_open:\n            raise SerialException(\"Port is already open.\")\n        self.fd = None\n        # open\n        try:\n>           self.fd = os.open(self.portstr, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           OSError: [Errno 6] No such device or address: '/dev/ttyUSB28'\n\n/usr/local/lib/python3.12/site-packages/serial/serialposix.py:322: OSError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <esptool.targets.esp32c6.ESP32C6ROM object at 0x7f797cda02c0>\nport = '/dev/ttyUSB28', baud = 115200, trace_enabled = False\n\n    def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):\n        \"\"\"Base constructor for ESPLoader bootloader interaction\n    \n        Don't call this constructor, either instantiate a specific\n        ROM class directly, or use cmds.detect_chip(). You can use the with\n        statement to ensure the serial port is closed when done.\n    \n        This base class has all of the instance methods for bootloader\n        functionality supported across various chips & stub\n        loaders. Subclasses replace the functions they don't support\n        with ones which throw NotImplementedInROMError().\n    \n        \"\"\"\n        # True if esptool detects the ROM is in Secure Download Mode\n        self.secure_download_mode = False\n        # True if esptool detects conditions which require the stub to be disabled\n        self.stub_is_disabled = False\n    \n        # Device-and-runtime-specific cache\n        self.cache = {\n            \"flash_id\": None,\n            \"uart_no\": None,\n            \"usb_pid\": None,\n            \"security_info\": None,\n        }\n    \n        if isinstance(port, str):\n            try:\n                self._port = serial.serial_for_url(\n                    port, exclusive=True, do_not_open=True\n                )\n                if sys.platform == \"win32\":\n                    # When opening a port on Windows,\n                    # the RTS/DTR (active low) lines\n                    # need to be set to False (pulled high)\n                    # to avoid unwanted chip reset\n                    self._port.rts = False\n                    self._port.dtr = False\n>               self._port.open()\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:363: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Serial<id=0x7f797cda0340, open=False>(port='/dev/ttyUSB28', baudrate=9600, bytesize=8, parity='N', stopbits=1, timeout=None, xonxoff=False, rtscts=False, dsrdtr=False)\n\n    def open(self):\n        \"\"\"\\\n        Open port with current settings. This may throw a SerialException\n        if the port cannot be opened.\"\"\"\n        if self._port is None:\n            raise SerialException(\"Port must be configured before it can be used.\")\n        if self.is_open:\n            raise SerialException(\"Port is already open.\")\n        self.fd = None\n        # open\n        try:\n            self.fd = os.open(self.portstr, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)\n        except OSError as msg:\n            self.fd = None\n>           raise SerialException(msg.errno, \"could not open port {}: {}\".format(self._port, msg))\nE           serial.serialutil.SerialException: [Errno 6] could not open port /dev/ttyUSB28: [Errno 6] No such device or address: '/dev/ttyUSB28'\n\n/usr/local/lib/python3.12/site-packages/serial/serialposix.py:325: SerialException\n\nDuring handling of the above exception, another exception occurred:\n\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7f797cda0080>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7f797ced2ea0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7f797cd98a40>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:501: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1131: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:98: in __init__\n    self.esp = esptool.get_default_connected_device(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1157: in get_default_connected_device\n    _esp = chip_class(each_port, initial_baud, trace)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <esptool.targets.esp32c6.ESP32C6ROM object at 0x7f797cda02c0>\nport = '/dev/ttyUSB28', baud = 115200, trace_enabled = False\n\n    def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):\n        \"\"\"Base constructor for ESPLoader bootloader interaction\n    \n        Don't call this constructor, either instantiate a specific\n        ROM class directly, or use cmds.detect_chip(). You can use the with\n        statement to ensure the serial port is closed when done.\n    \n        This base class has all of the instance methods for bootloader\n        functionality supported across various chips & stub\n        loaders. Subclasses replace the functions they don't support\n        with ones which throw NotImplementedInROMError().\n    \n        \"\"\"\n        # True if esptool detects the ROM is in Secure Download Mode\n        self.secure_download_mode = False\n        # True if esptool detects conditions which require the stub to be disabled\n        self.stub_is_disabled = False\n    \n        # Device-and-runtime-specific cache\n        self.cache = {\n            \"flash_id\": None,\n            \"uart_no\": None,\n            \"usb_pid\": None,\n            \"security_info\": None,\n        }\n    \n        if isinstance(port, str):\n            try:\n                self._port = serial.serial_for_url(\n                    port, exclusive=True, do_not_open=True\n                )\n                if sys.platform == \"win32\":\n                    # When opening a port on Windows,\n                    # the RTS/DTR (active low) lines\n                    # need to be set to False (pulled high)\n                    # to avoid unwanted chip reset\n                    self._port.rts = False\n                    self._port.dtr = False\n                self._port.open()\n            except serial.serialutil.SerialException as e:\n                port_issues = [\n                    [  # does not exist error\n                        re.compile(r\"Errno 2|FileNotFoundError\", re.IGNORECASE),\n                        \"Check if the port is correct and ESP connected\",\n                    ],\n                    [  # busy port error\n                        re.compile(r\"Access is denied\", re.IGNORECASE),\n                        \"Check if the port is not used by another task\",\n                    ],\n                ]\n                if sys.platform.startswith(\"linux\"):\n                    port_issues.append(\n                        [  # permission denied error\n                            re.compile(r\"Permission denied\", re.IGNORECASE),\n                            (\"Try to add user into dialout or uucp group.\"),\n                        ],\n                    )\n    \n                hint_msg = \"\"\n                for port_issue in port_issues:\n                    if port_issue[0].search(str(e)):\n                        hint_msg = f\"\\nHint: {port_issue[1]}\\n\"\n                        break\n    \n>               raise FatalError(\n                    f\"Could not open {port}, the port is busy or doesn't exist.\"\n                    f\"\\n({e})\\n\"\n                    f\"{hint_msg}\"\n                )\nE               esptool.util.FatalError: Could not open /dev/ttyUSB28, the port is busy or doesn't exist.\nE               ([Errno 6] could not open port /dev/ttyUSB28: [Errno 6] No such device or address: '/dev/ttyUSB28')\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:389: FatalError"
    },
    {
      "path": "performance.coremark.test_coremark",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/performance/coremark/esp32c6/coremark.xml [took 0s]",
      "title": "1 out of 7 runs with error: test_coremark (performance.coremark.test_coremark)",
      "raw_details": "failed on setup with \"esptool.util.FatalError: Could not open /dev/ttyUSB28, the port is busy or doesn't exist.\n([Errno 6] could not open port /dev/ttyUSB28: [Errno 6] No such device or address: '/dev/ttyUSB28')\"\nself = Serial<id=0x7fde26eac640, open=False>(port='/dev/ttyUSB28', baudrate=9600, bytesize=8, parity='N', stopbits=1, timeout=None, xonxoff=False, rtscts=False, dsrdtr=False)\n\n    def open(self):\n        \"\"\"\\\n        Open port with current settings. This may throw a SerialException\n        if the port cannot be opened.\"\"\"\n        if self._port is None:\n            raise SerialException(\"Port must be configured before it can be used.\")\n        if self.is_open:\n            raise SerialException(\"Port is already open.\")\n        self.fd = None\n        # open\n        try:\n>           self.fd = os.open(self.portstr, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           OSError: [Errno 6] No such device or address: '/dev/ttyUSB28'\n\n/usr/local/lib/python3.12/site-packages/serial/serialposix.py:322: OSError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <esptool.targets.esp32c6.ESP32C6ROM object at 0x7fde26eac6e0>\nport = '/dev/ttyUSB28', baud = 115200, trace_enabled = False\n\n    def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):\n        \"\"\"Base constructor for ESPLoader bootloader interaction\n    \n        Don't call this constructor, either instantiate a specific\n        ROM class directly, or use cmds.detect_chip(). You can use the with\n        statement to ensure the serial port is closed when done.\n    \n        This base class has all of the instance methods for bootloader\n        functionality supported across various chips & stub\n        loaders. Subclasses replace the functions they don't support\n        with ones which throw NotImplementedInROMError().\n    \n        \"\"\"\n        # True if esptool detects the ROM is in Secure Download Mode\n        self.secure_download_mode = False\n        # True if esptool detects conditions which require the stub to be disabled\n        self.stub_is_disabled = False\n    \n        # Device-and-runtime-specific cache\n        self.cache = {\n            \"flash_id\": None,\n            \"uart_no\": None,\n            \"usb_pid\": None,\n            \"security_info\": None,\n        }\n    \n        if isinstance(port, str):\n            try:\n                self._port = serial.serial_for_url(\n                    port, exclusive=True, do_not_open=True\n                )\n                if sys.platform == \"win32\":\n                    # When opening a port on Windows,\n                    # the RTS/DTR (active low) lines\n                    # need to be set to False (pulled high)\n                    # to avoid unwanted chip reset\n                    self._port.rts = False\n                    self._port.dtr = False\n>               self._port.open()\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:363: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Serial<id=0x7fde26eac640, open=False>(port='/dev/ttyUSB28', baudrate=9600, bytesize=8, parity='N', stopbits=1, timeout=None, xonxoff=False, rtscts=False, dsrdtr=False)\n\n    def open(self):\n        \"\"\"\\\n        Open port with current settings. This may throw a SerialException\n        if the port cannot be opened.\"\"\"\n        if self._port is None:\n            raise SerialException(\"Port must be configured before it can be used.\")\n        if self.is_open:\n            raise SerialException(\"Port is already open.\")\n        self.fd = None\n        # open\n        try:\n            self.fd = os.open(self.portstr, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)\n        except OSError as msg:\n            self.fd = None\n>           raise SerialException(msg.errno, \"could not open port {}: {}\".format(self._port, msg))\nE           serial.serialutil.SerialException: [Errno 6] could not open port /dev/ttyUSB28: [Errno 6] No such device or address: '/dev/ttyUSB28'\n\n/usr/local/lib/python3.12/site-packages/serial/serialposix.py:325: SerialException\n\nDuring handling of the above exception, another exception occurred:\n\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7fde26eac3e0>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7fde270393a0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7fde26eb49a0>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:501: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1131: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:98: in __init__\n    self.esp = esptool.get_default_connected_device(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1157: in get_default_connected_device\n    _esp = chip_class(each_port, initial_baud, trace)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <esptool.targets.esp32c6.ESP32C6ROM object at 0x7fde26eac6e0>\nport = '/dev/ttyUSB28', baud = 115200, trace_enabled = False\n\n    def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):\n        \"\"\"Base constructor for ESPLoader bootloader interaction\n    \n        Don't call this constructor, either instantiate a specific\n        ROM class directly, or use cmds.detect_chip(). You can use the with\n        statement to ensure the serial port is closed when done.\n    \n        This base class has all of the instance methods for bootloader\n        functionality supported across various chips & stub\n        loaders. Subclasses replace the functions they don't support\n        with ones which throw NotImplementedInROMError().\n    \n        \"\"\"\n        # True if esptool detects the ROM is in Secure Download Mode\n        self.secure_download_mode = False\n        # True if esptool detects conditions which require the stub to be disabled\n        self.stub_is_disabled = False\n    \n        # Device-and-runtime-specific cache\n        self.cache = {\n            \"flash_id\": None,\n            \"uart_no\": None,\n            \"usb_pid\": None,\n            \"security_info\": None,\n        }\n    \n        if isinstance(port, str):\n            try:\n                self._port = serial.serial_for_url(\n                    port, exclusive=True, do_not_open=True\n                )\n                if sys.platform == \"win32\":\n                    # When opening a port on Windows,\n                    # the RTS/DTR (active low) lines\n                    # need to be set to False (pulled high)\n                    # to avoid unwanted chip reset\n                    self._port.rts = False\n                    self._port.dtr = False\n                self._port.open()\n            except serial.serialutil.SerialException as e:\n                port_issues = [\n                    [  # does not exist error\n                        re.compile(r\"Errno 2|FileNotFoundError\", re.IGNORECASE),\n                        \"Check if the port is correct and ESP connected\",\n                    ],\n                    [  # busy port error\n                        re.compile(r\"Access is denied\", re.IGNORECASE),\n                        \"Check if the port is not used by another task\",\n                    ],\n                ]\n                if sys.platform.startswith(\"linux\"):\n                    port_issues.append(\n                        [  # permission denied error\n                            re.compile(r\"Permission denied\", re.IGNORECASE),\n                            (\"Try to add user into dialout or uucp group.\"),\n                        ],\n                    )\n    \n                hint_msg = \"\"\n                for port_issue in port_issues:\n                    if port_issue[0].search(str(e)):\n                        hint_msg = f\"\\nHint: {port_issue[1]}\\n\"\n                        break\n    \n>               raise FatalError(\n                    f\"Could not open {port}, the port is busy or doesn't exist.\"\n                    f\"\\n({e})\\n\"\n                    f\"{hint_msg}\"\n                )\nE               esptool.util.FatalError: Could not open /dev/ttyUSB28, the port is busy or doesn't exist.\nE               ([Errno 6] could not open port /dev/ttyUSB28: [Errno 6] No such device or address: '/dev/ttyUSB28')\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:389: FatalError"
    },
    {
      "path": "performance.linpack_float.test_linpack_float",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/performance/linpack_float/esp32c6/linpack_float.xml [took 0s]",
      "title": "1 out of 7 runs with error: test_linpack_float (performance.linpack_float.test_linpack_float)",
      "raw_details": "failed on setup with \"esptool.util.FatalError: Could not open /dev/ttyUSB28, the port is busy or doesn't exist.\n([Errno 6] could not open port /dev/ttyUSB28: [Errno 6] No such device or address: '/dev/ttyUSB28')\"\nself = Serial<id=0x7f2783e04b80, open=False>(port='/dev/ttyUSB28', baudrate=9600, bytesize=8, parity='N', stopbits=1, timeout=None, xonxoff=False, rtscts=False, dsrdtr=False)\n\n    def open(self):\n        \"\"\"\\\n        Open port with current settings. This may throw a SerialException\n        if the port cannot be opened.\"\"\"\n        if self._port is None:\n            raise SerialException(\"Port must be configured before it can be used.\")\n        if self.is_open:\n            raise SerialException(\"Port is already open.\")\n        self.fd = None\n        # open\n        try:\n>           self.fd = os.open(self.portstr, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           OSError: [Errno 6] No such device or address: '/dev/ttyUSB28'\n\n/usr/local/lib/python3.12/site-packages/serial/serialposix.py:322: OSError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <esptool.targets.esp32c6.ESP32C6ROM object at 0x7f2783e04b60>\nport = '/dev/ttyUSB28', baud = 115200, trace_enabled = False\n\n    def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):\n        \"\"\"Base constructor for ESPLoader bootloader interaction\n    \n        Don't call this constructor, either instantiate a specific\n        ROM class directly, or use cmds.detect_chip(). You can use the with\n        statement to ensure the serial port is closed when done.\n    \n        This base class has all of the instance methods for bootloader\n        functionality supported across various chips & stub\n        loaders. Subclasses replace the functions they don't support\n        with ones which throw NotImplementedInROMError().\n    \n        \"\"\"\n        # True if esptool detects the ROM is in Secure Download Mode\n        self.secure_download_mode = False\n        # True if esptool detects conditions which require the stub to be disabled\n        self.stub_is_disabled = False\n    \n        # Device-and-runtime-specific cache\n        self.cache = {\n            \"flash_id\": None,\n            \"uart_no\": None,\n            \"usb_pid\": None,\n            \"security_info\": None,\n        }\n    \n        if isinstance(port, str):\n            try:\n                self._port = serial.serial_for_url(\n                    port, exclusive=True, do_not_open=True\n                )\n                if sys.platform == \"win32\":\n                    # When opening a port on Windows,\n                    # the RTS/DTR (active low) lines\n                    # need to be set to False (pulled high)\n                    # to avoid unwanted chip reset\n                    self._port.rts = False\n                    self._port.dtr = False\n>               self._port.open()\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:363: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Serial<id=0x7f2783e04b80, open=False>(port='/dev/ttyUSB28', baudrate=9600, bytesize=8, parity='N', stopbits=1, timeout=None, xonxoff=False, rtscts=False, dsrdtr=False)\n\n    def open(self):\n        \"\"\"\\\n        Open port with current settings. This may throw a SerialException\n        if the port cannot be opened.\"\"\"\n        if self._port is None:\n            raise SerialException(\"Port must be configured before it can be used.\")\n        if self.is_open:\n            raise SerialException(\"Port is already open.\")\n        self.fd = None\n        # open\n        try:\n            self.fd = os.open(self.portstr, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)\n        except OSError as msg:\n            self.fd = None\n>           raise SerialException(msg.errno, \"could not open port {}: {}\".format(self._port, msg))\nE           serial.serialutil.SerialException: [Errno 6] could not open port /dev/ttyUSB28: [Errno 6] No such device or address: '/dev/ttyUSB28'\n\n/usr/local/lib/python3.12/site-packages/serial/serialposix.py:325: SerialException\n\nDuring handling of the above exception, another exception occurred:\n\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7f2783e04920>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7f278400d7c0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7f2783e08a40>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:501: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1131: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:98: in __init__\n    self.esp = esptool.get_default_connected_device(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1157: in get_default_connected_device\n    _esp = chip_class(each_port, initial_baud, trace)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <esptool.targets.esp32c6.ESP32C6ROM object at 0x7f2783e04b60>\nport = '/dev/ttyUSB28', baud = 115200, trace_enabled = False\n\n    def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):\n        \"\"\"Base constructor for ESPLoader bootloader interaction\n    \n        Don't call this constructor, either instantiate a specific\n        ROM class directly, or use cmds.detect_chip(). You can use the with\n        statement to ensure the serial port is closed when done.\n    \n        This base class has all of the instance methods for bootloader\n        functionality supported across various chips & stub\n        loaders. Subclasses replace the functions they don't support\n        with ones which throw NotImplementedInROMError().\n    \n        \"\"\"\n        # True if esptool detects the ROM is in Secure Download Mode\n        self.secure_download_mode = False\n        # True if esptool detects conditions which require the stub to be disabled\n        self.stub_is_disabled = False\n    \n        # Device-and-runtime-specific cache\n        self.cache = {\n            \"flash_id\": None,\n            \"uart_no\": None,\n            \"usb_pid\": None,\n            \"security_info\": None,\n        }\n    \n        if isinstance(port, str):\n            try:\n                self._port = serial.serial_for_url(\n                    port, exclusive=True, do_not_open=True\n                )\n                if sys.platform == \"win32\":\n                    # When opening a port on Windows,\n                    # the RTS/DTR (active low) lines\n                    # need to be set to False (pulled high)\n                    # to avoid unwanted chip reset\n                    self._port.rts = False\n                    self._port.dtr = False\n                self._port.open()\n            except serial.serialutil.SerialException as e:\n                port_issues = [\n                    [  # does not exist error\n                        re.compile(r\"Errno 2|FileNotFoundError\", re.IGNORECASE),\n                        \"Check if the port is correct and ESP connected\",\n                    ],\n                    [  # busy port error\n                        re.compile(r\"Access is denied\", re.IGNORECASE),\n                        \"Check if the port is not used by another task\",\n                    ],\n                ]\n                if sys.platform.startswith(\"linux\"):\n                    port_issues.append(\n                        [  # permission denied error\n                            re.compile(r\"Permission denied\", re.IGNORECASE),\n                            (\"Try to add user into dialout or uucp group.\"),\n                        ],\n                    )\n    \n                hint_msg = \"\"\n                for port_issue in port_issues:\n                    if port_issue[0].search(str(e)):\n                        hint_msg = f\"\\nHint: {port_issue[1]}\\n\"\n                        break\n    \n>               raise FatalError(\n                    f\"Could not open {port}, the port is busy or doesn't exist.\"\n                    f\"\\n({e})\\n\"\n                    f\"{hint_msg}\"\n                )\nE               esptool.util.FatalError: Could not open /dev/ttyUSB28, the port is busy or doesn't exist.\nE               ([Errno 6] could not open port /dev/ttyUSB28: [Errno 6] No such device or address: '/dev/ttyUSB28')\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:389: FatalError"
    },
    {
      "path": "performance.ramspeed.test_ramspeed",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/performance/ramspeed/esp32c6/ramspeed.xml [took 0s]",
      "title": "1 out of 7 runs with error: test_ramspeed (performance.ramspeed.test_ramspeed)",
      "raw_details": "failed on setup with \"esptool.util.FatalError: Could not open /dev/ttyUSB28, the port is busy or doesn't exist.\n([Errno 6] could not open port /dev/ttyUSB28: [Errno 6] No such device or address: '/dev/ttyUSB28')\"\nself = Serial<id=0x7f5223c44a30, open=False>(port='/dev/ttyUSB28', baudrate=9600, bytesize=8, parity='N', stopbits=1, timeout=None, xonxoff=False, rtscts=False, dsrdtr=False)\n\n    def open(self):\n        \"\"\"\\\n        Open port with current settings. This may throw a SerialException\n        if the port cannot be opened.\"\"\"\n        if self._port is None:\n            raise SerialException(\"Port must be configured before it can be used.\")\n        if self.is_open:\n            raise SerialException(\"Port is already open.\")\n        self.fd = None\n        # open\n        try:\n>           self.fd = os.open(self.portstr, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           OSError: [Errno 6] No such device or address: '/dev/ttyUSB28'\n\n/usr/local/lib/python3.12/site-packages/serial/serialposix.py:322: OSError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <esptool.targets.esp32c6.ESP32C6ROM object at 0x7f522404e7b0>\nport = '/dev/ttyUSB28', baud = 115200, trace_enabled = False\n\n    def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):\n        \"\"\"Base constructor for ESPLoader bootloader interaction\n    \n        Don't call this constructor, either instantiate a specific\n        ROM class directly, or use cmds.detect_chip(). You can use the with\n        statement to ensure the serial port is closed when done.\n    \n        This base class has all of the instance methods for bootloader\n        functionality supported across various chips & stub\n        loaders. Subclasses replace the functions they don't support\n        with ones which throw NotImplementedInROMError().\n    \n        \"\"\"\n        # True if esptool detects the ROM is in Secure Download Mode\n        self.secure_download_mode = False\n        # True if esptool detects conditions which require the stub to be disabled\n        self.stub_is_disabled = False\n    \n        # Device-and-runtime-specific cache\n        self.cache = {\n            \"flash_id\": None,\n            \"uart_no\": None,\n            \"usb_pid\": None,\n            \"security_info\": None,\n        }\n    \n        if isinstance(port, str):\n            try:\n                self._port = serial.serial_for_url(\n                    port, exclusive=True, do_not_open=True\n                )\n                if sys.platform == \"win32\":\n                    # When opening a port on Windows,\n                    # the RTS/DTR (active low) lines\n                    # need to be set to False (pulled high)\n                    # to avoid unwanted chip reset\n                    self._port.rts = False\n                    self._port.dtr = False\n>               self._port.open()\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:363: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Serial<id=0x7f5223c44a30, open=False>(port='/dev/ttyUSB28', baudrate=9600, bytesize=8, parity='N', stopbits=1, timeout=None, xonxoff=False, rtscts=False, dsrdtr=False)\n\n    def open(self):\n        \"\"\"\\\n        Open port with current settings. This may throw a SerialException\n        if the port cannot be opened.\"\"\"\n        if self._port is None:\n            raise SerialException(\"Port must be configured before it can be used.\")\n        if self.is_open:\n            raise SerialException(\"Port is already open.\")\n        self.fd = None\n        # open\n        try:\n            self.fd = os.open(self.portstr, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)\n        except OSError as msg:\n            self.fd = None\n>           raise SerialException(msg.errno, \"could not open port {}: {}\".format(self._port, msg))\nE           serial.serialutil.SerialException: [Errno 6] could not open port /dev/ttyUSB28: [Errno 6] No such device or address: '/dev/ttyUSB28'\n\n/usr/local/lib/python3.12/site-packages/serial/serialposix.py:325: SerialException\n\nDuring handling of the above exception, another exception occurred:\n\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7f5223c447a0>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7f5223d7b4d0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7f5223c489a0>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:501: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1131: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:98: in __init__\n    self.esp = esptool.get_default_connected_device(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1157: in get_default_connected_device\n    _esp = chip_class(each_port, initial_baud, trace)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <esptool.targets.esp32c6.ESP32C6ROM object at 0x7f522404e7b0>\nport = '/dev/ttyUSB28', baud = 115200, trace_enabled = False\n\n    def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):\n        \"\"\"Base constructor for ESPLoader bootloader interaction\n    \n        Don't call this constructor, either instantiate a specific\n        ROM class directly, or use cmds.detect_chip(). You can use the with\n        statement to ensure the serial port is closed when done.\n    \n        This base class has all of the instance methods for bootloader\n        functionality supported across various chips & stub\n        loaders. Subclasses replace the functions they don't support\n        with ones which throw NotImplementedInROMError().\n    \n        \"\"\"\n        # True if esptool detects the ROM is in Secure Download Mode\n        self.secure_download_mode = False\n        # True if esptool detects conditions which require the stub to be disabled\n        self.stub_is_disabled = False\n    \n        # Device-and-runtime-specific cache\n        self.cache = {\n            \"flash_id\": None,\n            \"uart_no\": None,\n            \"usb_pid\": None,\n            \"security_info\": None,\n        }\n    \n        if isinstance(port, str):\n            try:\n                self._port = serial.serial_for_url(\n                    port, exclusive=True, do_not_open=True\n                )\n                if sys.platform == \"win32\":\n                    # When opening a port on Windows,\n                    # the RTS/DTR (active low) lines\n                    # need to be set to False (pulled high)\n                    # to avoid unwanted chip reset\n                    self._port.rts = False\n                    self._port.dtr = False\n                self._port.open()\n            except serial.serialutil.SerialException as e:\n                port_issues = [\n                    [  # does not exist error\n                        re.compile(r\"Errno 2|FileNotFoundError\", re.IGNORECASE),\n                        \"Check if the port is correct and ESP connected\",\n                    ],\n                    [  # busy port error\n                        re.compile(r\"Access is denied\", re.IGNORECASE),\n                        \"Check if the port is not used by another task\",\n                    ],\n                ]\n                if sys.platform.startswith(\"linux\"):\n                    port_issues.append(\n                        [  # permission denied error\n                            re.compile(r\"Permission denied\", re.IGNORECASE),\n                            (\"Try to add user into dialout or uucp group.\"),\n                        ],\n                    )\n    \n                hint_msg = \"\"\n                for port_issue in port_issues:\n                    if port_issue[0].search(str(e)):\n                        hint_msg = f\"\\nHint: {port_issue[1]}\\n\"\n                        break\n    \n>               raise FatalError(\n                    f\"Could not open {port}, the port is busy or doesn't exist.\"\n                    f\"\\n({e})\\n\"\n                    f\"{hint_msg}\"\n                )\nE               esptool.util.FatalError: Could not open /dev/ttyUSB28, the port is busy or doesn't exist.\nE               ([Errno 6] could not open port /dev/ttyUSB28: [Errno 6] No such device or address: '/dev/ttyUSB28')\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:389: FatalError"
    },
    {
      "path": "performance.superpi.test_superpi",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/performance/superpi/esp32c6/superpi.xml [took 0s]",
      "title": "1 out of 7 runs with error: test_superpi (performance.superpi.test_superpi)",
      "raw_details": "failed on setup with \"esptool.util.FatalError: Could not open /dev/ttyUSB28, the port is busy or doesn't exist.\n([Errno 6] could not open port /dev/ttyUSB28: [Errno 6] No such device or address: '/dev/ttyUSB28')\"\nself = Serial<id=0x7fd0bd0e8610, open=False>(port='/dev/ttyUSB28', baudrate=9600, bytesize=8, parity='N', stopbits=1, timeout=None, xonxoff=False, rtscts=False, dsrdtr=False)\n\n    def open(self):\n        \"\"\"\\\n        Open port with current settings. This may throw a SerialException\n        if the port cannot be opened.\"\"\"\n        if self._port is None:\n            raise SerialException(\"Port must be configured before it can be used.\")\n        if self.is_open:\n            raise SerialException(\"Port is already open.\")\n        self.fd = None\n        # open\n        try:\n>           self.fd = os.open(self.portstr, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           OSError: [Errno 6] No such device or address: '/dev/ttyUSB28'\n\n/usr/local/lib/python3.12/site-packages/serial/serialposix.py:322: OSError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <esptool.targets.esp32c6.ESP32C6ROM object at 0x7fd0bd0e8770>\nport = '/dev/ttyUSB28', baud = 115200, trace_enabled = False\n\n    def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):\n        \"\"\"Base constructor for ESPLoader bootloader interaction\n    \n        Don't call this constructor, either instantiate a specific\n        ROM class directly, or use cmds.detect_chip(). You can use the with\n        statement to ensure the serial port is closed when done.\n    \n        This base class has all of the instance methods for bootloader\n        functionality supported across various chips & stub\n        loaders. Subclasses replace the functions they don't support\n        with ones which throw NotImplementedInROMError().\n    \n        \"\"\"\n        # True if esptool detects the ROM is in Secure Download Mode\n        self.secure_download_mode = False\n        # True if esptool detects conditions which require the stub to be disabled\n        self.stub_is_disabled = False\n    \n        # Device-and-runtime-specific cache\n        self.cache = {\n            \"flash_id\": None,\n            \"uart_no\": None,\n            \"usb_pid\": None,\n            \"security_info\": None,\n        }\n    \n        if isinstance(port, str):\n            try:\n                self._port = serial.serial_for_url(\n                    port, exclusive=True, do_not_open=True\n                )\n                if sys.platform == \"win32\":\n                    # When opening a port on Windows,\n                    # the RTS/DTR (active low) lines\n                    # need to be set to False (pulled high)\n                    # to avoid unwanted chip reset\n                    self._port.rts = False\n                    self._port.dtr = False\n>               self._port.open()\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:363: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Serial<id=0x7fd0bd0e8610, open=False>(port='/dev/ttyUSB28', baudrate=9600, bytesize=8, parity='N', stopbits=1, timeout=None, xonxoff=False, rtscts=False, dsrdtr=False)\n\n    def open(self):\n        \"\"\"\\\n        Open port with current settings. This may throw a SerialException\n        if the port cannot be opened.\"\"\"\n        if self._port is None:\n            raise SerialException(\"Port must be configured before it can be used.\")\n        if self.is_open:\n            raise SerialException(\"Port is already open.\")\n        self.fd = None\n        # open\n        try:\n            self.fd = os.open(self.portstr, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)\n        except OSError as msg:\n            self.fd = None\n>           raise SerialException(msg.errno, \"could not open port {}: {}\".format(self._port, msg))\nE           serial.serialutil.SerialException: [Errno 6] could not open port /dev/ttyUSB28: [Errno 6] No such device or address: '/dev/ttyUSB28'\n\n/usr/local/lib/python3.12/site-packages/serial/serialposix.py:325: SerialException\n\nDuring handling of the above exception, another exception occurred:\n\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7fd0bd0e8470>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7fd0bd1ba690>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7fd0bd0ec9a0>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:501: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1131: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:98: in __init__\n    self.esp = esptool.get_default_connected_device(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1157: in get_default_connected_device\n    _esp = chip_class(each_port, initial_baud, trace)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <esptool.targets.esp32c6.ESP32C6ROM object at 0x7fd0bd0e8770>\nport = '/dev/ttyUSB28', baud = 115200, trace_enabled = False\n\n    def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):\n        \"\"\"Base constructor for ESPLoader bootloader interaction\n    \n        Don't call this constructor, either instantiate a specific\n        ROM class directly, or use cmds.detect_chip(). You can use the with\n        statement to ensure the serial port is closed when done.\n    \n        This base class has all of the instance methods for bootloader\n        functionality supported across various chips & stub\n        loaders. Subclasses replace the functions they don't support\n        with ones which throw NotImplementedInROMError().\n    \n        \"\"\"\n        # True if esptool detects the ROM is in Secure Download Mode\n        self.secure_download_mode = False\n        # True if esptool detects conditions which require the stub to be disabled\n        self.stub_is_disabled = False\n    \n        # Device-and-runtime-specific cache\n        self.cache = {\n            \"flash_id\": None,\n            \"uart_no\": None,\n            \"usb_pid\": None,\n            \"security_info\": None,\n        }\n    \n        if isinstance(port, str):\n            try:\n                self._port = serial.serial_for_url(\n                    port, exclusive=True, do_not_open=True\n                )\n                if sys.platform == \"win32\":\n                    # When opening a port on Windows,\n                    # the RTS/DTR (active low) lines\n                    # need to be set to False (pulled high)\n                    # to avoid unwanted chip reset\n                    self._port.rts = False\n                    self._port.dtr = False\n                self._port.open()\n            except serial.serialutil.SerialException as e:\n                port_issues = [\n                    [  # does not exist error\n                        re.compile(r\"Errno 2|FileNotFoundError\", re.IGNORECASE),\n                        \"Check if the port is correct and ESP connected\",\n                    ],\n                    [  # busy port error\n                        re.compile(r\"Access is denied\", re.IGNORECASE),\n                        \"Check if the port is not used by another task\",\n                    ],\n                ]\n                if sys.platform.startswith(\"linux\"):\n                    port_issues.append(\n                        [  # permission denied error\n                            re.compile(r\"Permission denied\", re.IGNORECASE),\n                            (\"Try to add user into dialout or uucp group.\"),\n                        ],\n                    )\n    \n                hint_msg = \"\"\n                for port_issue in port_issues:\n                    if port_issue[0].search(str(e)):\n                        hint_msg = f\"\\nHint: {port_issue[1]}\\n\"\n                        break\n    \n>               raise FatalError(\n                    f\"Could not open {port}, the port is busy or doesn't exist.\"\n                    f\"\\n({e})\\n\"\n                    f\"{hint_msg}\"\n                )\nE               esptool.util.FatalError: Could not open /dev/ttyUSB28, the port is busy or doesn't exist.\nE               ([Errno 6] could not open port /dev/ttyUSB28: [Errno 6] No such device or address: '/dev/ttyUSB28')\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:389: FatalError"
    },
    {
      "path": "hardware.missing_runner",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/wifi/esp32s3/wifi2.xml",
      "title": "wifi2 (hardware.missing_runner) with error",
      "raw_details": "No available runner matches required tags: esp32s3 wifi_router (chip=esp32s3)\nThe hardware test could not be scheduled because no runner with the required tag combination is online/available."
    },
    {
      "path": "performance.fibonacci.test_fibonacci",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/performance/fibonacci/esp32c6/fibonacci.xml [took 0s]",
      "title": "1 out of 7 runs with error: test_fibonacci (performance.fibonacci.test_fibonacci)",
      "raw_details": "failed on setup with \"esptool.util.FatalError: Could not open /dev/ttyUSB28, the port is busy or doesn't exist.\n([Errno 6] could not open port /dev/ttyUSB28: [Errno 6] No such device or address: '/dev/ttyUSB28')\"\nself = Serial<id=0x7f7030fc2710, open=False>(port='/dev/ttyUSB28', baudrate=9600, bytesize=8, parity='N', stopbits=1, timeout=None, xonxoff=False, rtscts=False, dsrdtr=False)\n\n    def open(self):\n        \"\"\"\\\n        Open port with current settings. This may throw a SerialException\n        if the port cannot be opened.\"\"\"\n        if self._port is None:\n            raise SerialException(\"Port must be configured before it can be used.\")\n        if self.is_open:\n            raise SerialException(\"Port is already open.\")\n        self.fd = None\n        # open\n        try:\n>           self.fd = os.open(self.portstr, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           OSError: [Errno 6] No such device or address: '/dev/ttyUSB28'\n\n/usr/local/lib/python3.12/site-packages/serial/serialposix.py:322: OSError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <esptool.targets.esp32c6.ESP32C6ROM object at 0x7f7031034d10>\nport = '/dev/ttyUSB28', baud = 115200, trace_enabled = False\n\n    def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):\n        \"\"\"Base constructor for ESPLoader bootloader interaction\n    \n        Don't call this constructor, either instantiate a specific\n        ROM class directly, or use cmds.detect_chip(). You can use the with\n        statement to ensure the serial port is closed when done.\n    \n        This base class has all of the instance methods for bootloader\n        functionality supported across various chips & stub\n        loaders. Subclasses replace the functions they don't support\n        with ones which throw NotImplementedInROMError().\n    \n        \"\"\"\n        # True if esptool detects the ROM is in Secure Download Mode\n        self.secure_download_mode = False\n        # True if esptool detects conditions which require the stub to be disabled\n        self.stub_is_disabled = False\n    \n        # Device-and-runtime-specific cache\n        self.cache = {\n            \"flash_id\": None,\n            \"uart_no\": None,\n            \"usb_pid\": None,\n            \"security_info\": None,\n        }\n    \n        if isinstance(port, str):\n            try:\n                self._port = serial.serial_for_url(\n                    port, exclusive=True, do_not_open=True\n                )\n                if sys.platform == \"win32\":\n                    # When opening a port on Windows,\n                    # the RTS/DTR (active low) lines\n                    # need to be set to False (pulled high)\n                    # to avoid unwanted chip reset\n                    self._port.rts = False\n                    self._port.dtr = False\n>               self._port.open()\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:363: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Serial<id=0x7f7030fc2710, open=False>(port='/dev/ttyUSB28', baudrate=9600, bytesize=8, parity='N', stopbits=1, timeout=None, xonxoff=False, rtscts=False, dsrdtr=False)\n\n    def open(self):\n        \"\"\"\\\n        Open port with current settings. This may throw a SerialException\n        if the port cannot be opened.\"\"\"\n        if self._port is None:\n            raise SerialException(\"Port must be configured before it can be used.\")\n        if self.is_open:\n            raise SerialException(\"Port is already open.\")\n        self.fd = None\n        # open\n        try:\n            self.fd = os.open(self.portstr, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)\n        except OSError as msg:\n            self.fd = None\n>           raise SerialException(msg.errno, \"could not open port {}: {}\".format(self._port, msg))\nE           serial.serialutil.SerialException: [Errno 6] could not open port /dev/ttyUSB28: [Errno 6] No such device or address: '/dev/ttyUSB28'\n\n/usr/local/lib/python3.12/site-packages/serial/serialposix.py:325: SerialException\n\nDuring handling of the above exception, another exception occurred:\n\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7f7031034a10>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7f703110ade0>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7f7031038a40>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:501: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1131: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:98: in __init__\n    self.esp = esptool.get_default_connected_device(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1157: in get_default_connected_device\n    _esp = chip_class(each_port, initial_baud, trace)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <esptool.targets.esp32c6.ESP32C6ROM object at 0x7f7031034d10>\nport = '/dev/ttyUSB28', baud = 115200, trace_enabled = False\n\n    def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):\n        \"\"\"Base constructor for ESPLoader bootloader interaction\n    \n        Don't call this constructor, either instantiate a specific\n        ROM class directly, or use cmds.detect_chip(). You can use the with\n        statement to ensure the serial port is closed when done.\n    \n        This base class has all of the instance methods for bootloader\n        functionality supported across various chips & stub\n        loaders. Subclasses replace the functions they don't support\n        with ones which throw NotImplementedInROMError().\n    \n        \"\"\"\n        # True if esptool detects the ROM is in Secure Download Mode\n        self.secure_download_mode = False\n        # True if esptool detects conditions which require the stub to be disabled\n        self.stub_is_disabled = False\n    \n        # Device-and-runtime-specific cache\n        self.cache = {\n            \"flash_id\": None,\n            \"uart_no\": None,\n            \"usb_pid\": None,\n            \"security_info\": None,\n        }\n    \n        if isinstance(port, str):\n            try:\n                self._port = serial.serial_for_url(\n                    port, exclusive=True, do_not_open=True\n                )\n                if sys.platform == \"win32\":\n                    # When opening a port on Windows,\n                    # the RTS/DTR (active low) lines\n                    # need to be set to False (pulled high)\n                    # to avoid unwanted chip reset\n                    self._port.rts = False\n                    self._port.dtr = False\n                self._port.open()\n            except serial.serialutil.SerialException as e:\n                port_issues = [\n                    [  # does not exist error\n                        re.compile(r\"Errno 2|FileNotFoundError\", re.IGNORECASE),\n                        \"Check if the port is correct and ESP connected\",\n                    ],\n                    [  # busy port error\n                        re.compile(r\"Access is denied\", re.IGNORECASE),\n                        \"Check if the port is not used by another task\",\n                    ],\n                ]\n                if sys.platform.startswith(\"linux\"):\n                    port_issues.append(\n                        [  # permission denied error\n                            re.compile(r\"Permission denied\", re.IGNORECASE),\n                            (\"Try to add user into dialout or uucp group.\"),\n                        ],\n                    )\n    \n                hint_msg = \"\"\n                for port_issue in port_issues:\n                    if port_issue[0].search(str(e)):\n                        hint_msg = f\"\\nHint: {port_issue[1]}\\n\"\n                        break\n    \n>               raise FatalError(\n                    f\"Could not open {port}, the port is busy or doesn't exist.\"\n                    f\"\\n({e})\\n\"\n                    f\"{hint_msg}\"\n                )\nE               esptool.util.FatalError: Could not open /dev/ttyUSB28, the port is busy or doesn't exist.\nE               ([Errno 6] could not open port /dev/ttyUSB28: [Errno 6] No such device or address: '/dev/ttyUSB28')\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:389: FatalError"
    },
    {
      "path": "performance.psramspeed.test_psramspeed",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/performance/psramspeed/esp32s2/psramspeed.xml [took 0s]",
      "title": "1 out of 3 runs with error: test_psramspeed (performance.psramspeed.test_psramspeed)",
      "raw_details": "failed on setup with \"esptool.util.FatalError: Could not open /dev/ttyUSB0, the port is busy or doesn't exist.\n([Errno 6] could not open port /dev/ttyUSB0: [Errno 6] No such device or address: '/dev/ttyUSB0')\"\nself = Serial<id=0x7ff8ef5cc580, open=False>(port='/dev/ttyUSB0', baudrate=9600, bytesize=8, parity='N', stopbits=1, timeout=None, xonxoff=False, rtscts=False, dsrdtr=False)\n\n    def open(self):\n        \"\"\"\\\n        Open port with current settings. This may throw a SerialException\n        if the port cannot be opened.\"\"\"\n        if self._port is None:\n            raise SerialException(\"Port must be configured before it can be used.\")\n        if self.is_open:\n            raise SerialException(\"Port is already open.\")\n        self.fd = None\n        # open\n        try:\n>           self.fd = os.open(self.portstr, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           OSError: [Errno 6] No such device or address: '/dev/ttyUSB0'\n\n/usr/local/lib/python3.12/site-packages/serial/serialposix.py:322: OSError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <esptool.targets.esp32s2.ESP32S2ROM object at 0x7ff8ef5cc680>\nport = '/dev/ttyUSB0', baud = 115200, trace_enabled = False\n\n    def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):\n        \"\"\"Base constructor for ESPLoader bootloader interaction\n    \n        Don't call this constructor, either instantiate a specific\n        ROM class directly, or use cmds.detect_chip(). You can use the with\n        statement to ensure the serial port is closed when done.\n    \n        This base class has all of the instance methods for bootloader\n        functionality supported across various chips & stub\n        loaders. Subclasses replace the functions they don't support\n        with ones which throw NotImplementedInROMError().\n    \n        \"\"\"\n        # True if esptool detects the ROM is in Secure Download Mode\n        self.secure_download_mode = False\n        # True if esptool detects conditions which require the stub to be disabled\n        self.stub_is_disabled = False\n    \n        # Device-and-runtime-specific cache\n        self.cache = {\n            \"flash_id\": None,\n            \"uart_no\": None,\n            \"usb_pid\": None,\n            \"security_info\": None,\n        }\n    \n        if isinstance(port, str):\n            try:\n                self._port = serial.serial_for_url(\n                    port, exclusive=True, do_not_open=True\n                )\n                if sys.platform == \"win32\":\n                    # When opening a port on Windows,\n                    # the RTS/DTR (active low) lines\n                    # need to be set to False (pulled high)\n                    # to avoid unwanted chip reset\n                    self._port.rts = False\n                    self._port.dtr = False\n>               self._port.open()\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:363: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Serial<id=0x7ff8ef5cc580, open=False>(port='/dev/ttyUSB0', baudrate=9600, bytesize=8, parity='N', stopbits=1, timeout=None, xonxoff=False, rtscts=False, dsrdtr=False)\n\n    def open(self):\n        \"\"\"\\\n        Open port with current settings. This may throw a SerialException\n        if the port cannot be opened.\"\"\"\n        if self._port is None:\n            raise SerialException(\"Port must be configured before it can be used.\")\n        if self.is_open:\n            raise SerialException(\"Port is already open.\")\n        self.fd = None\n        # open\n        try:\n            self.fd = os.open(self.portstr, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)\n        except OSError as msg:\n            self.fd = None\n>           raise SerialException(msg.errno, \"could not open port {}: {}\".format(self._port, msg))\nE           serial.serialutil.SerialException: [Errno 6] could not open port /dev/ttyUSB0: [Errno 6] No such device or address: '/dev/ttyUSB0'\n\n/usr/local/lib/python3.12/site-packages/serial/serialposix.py:325: SerialException\n\nDuring handling of the above exception, another exception occurred:\n\nargs = ()\nkwargs = {'_fixture_classes_and_options': ClassCliOptions(classes={'app': <class 'pytest_embedded_arduino.app.ArduinoApp'>, 'se...oApp object at 0x7ff8ef5cc380>, 'msg_queue': <AutoProxy[MessageQueue] object, typeid 'MessageQueue' at 0x7ff8ef66a570>}\n_close_or_terminate = <function multi_dut_generator_fixture.<locals>.wrapper.<locals>._close_or_terminate at 0x7ff8ef5d0900>\nres = None\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        def _close_or_terminate(obj):\n            if obj is None:\n                del obj\n                return\n    \n            try:\n                if isinstance(obj, subprocess.Popen | multiprocessing.process.BaseProcess):\n                    obj.terminate()\n                    obj.kill()\n                elif isinstance(obj, io.IOBase):\n                    try:\n                        obj.close()\n                    except Exception as e:\n                        logging.debug('file %s closed failed with error: %s', obj, str(e))\n                else:\n                    try:\n                        obj.close()\n                    except AttributeError:\n                        try:\n                            obj.terminate()\n                        except AttributeError:\n                            pass\n                    except Exception as e:\n                        logging.debug('Not properly caught object %s: %s', obj, str(e))\n            except Exception as e:\n                logging.debug('%s: %s', obj, str(e))\n                return  # swallow up all error\n            finally:\n                referrers = gc.get_referrers(obj)\n                for _referrer in referrers:\n                    if isinstance(_referrer, list):\n                        for _i, val in enumerate(_referrer):\n                            if val is obj:\n                                _referrer[_i] = None\n                    elif isinstance(_referrer, dict):\n                        for key, value in _referrer.items():\n                            if value is obj:\n                                _referrer[key] = None\n                del obj\n    \n        if _COUNT == 1:\n            res = None\n            try:\n>               res = func(*args, **kwargs)\n                      ^^^^^^^^^^^^^^^^^^^^^\n\n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:501: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/local/lib/python3.12/site-packages/pytest_embedded/plugin.py:1131: in serial\n    return serial_gn(**locals())\n           ^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded/dut_factory.py:482: in serial_gn\n    return cls(**_drop_none_kwargs(kwargs))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/usr/local/lib/python3.12/site-packages/pytest_embedded_arduino/serial.py:25: in __init__\n    super().__init__(\n/usr/local/lib/python3.12/site-packages/pytest_embedded_serial_esp/serial.py:98: in __init__\n    self.esp = esptool.get_default_connected_device(\n/usr/local/lib/python3.12/site-packages/esptool/__init__.py:1157: in get_default_connected_device\n    _esp = chip_class(each_port, initial_baud, trace)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <esptool.targets.esp32s2.ESP32S2ROM object at 0x7ff8ef5cc680>\nport = '/dev/ttyUSB0', baud = 115200, trace_enabled = False\n\n    def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):\n        \"\"\"Base constructor for ESPLoader bootloader interaction\n    \n        Don't call this constructor, either instantiate a specific\n        ROM class directly, or use cmds.detect_chip(). You can use the with\n        statement to ensure the serial port is closed when done.\n    \n        This base class has all of the instance methods for bootloader\n        functionality supported across various chips & stub\n        loaders. Subclasses replace the functions they don't support\n        with ones which throw NotImplementedInROMError().\n    \n        \"\"\"\n        # True if esptool detects the ROM is in Secure Download Mode\n        self.secure_download_mode = False\n        # True if esptool detects conditions which require the stub to be disabled\n        self.stub_is_disabled = False\n    \n        # Device-and-runtime-specific cache\n        self.cache = {\n            \"flash_id\": None,\n            \"uart_no\": None,\n            \"usb_pid\": None,\n            \"security_info\": None,\n        }\n    \n        if isinstance(port, str):\n            try:\n                self._port = serial.serial_for_url(\n                    port, exclusive=True, do_not_open=True\n                )\n                if sys.platform == \"win32\":\n                    # When opening a port on Windows,\n                    # the RTS/DTR (active low) lines\n                    # need to be set to False (pulled high)\n                    # to avoid unwanted chip reset\n                    self._port.rts = False\n                    self._port.dtr = False\n                self._port.open()\n            except serial.serialutil.SerialException as e:\n                port_issues = [\n                    [  # does not exist error\n                        re.compile(r\"Errno 2|FileNotFoundError\", re.IGNORECASE),\n                        \"Check if the port is correct and ESP connected\",\n                    ],\n                    [  # busy port error\n                        re.compile(r\"Access is denied\", re.IGNORECASE),\n                        \"Check if the port is not used by another task\",\n                    ],\n                ]\n                if sys.platform.startswith(\"linux\"):\n                    port_issues.append(\n                        [  # permission denied error\n                            re.compile(r\"Permission denied\", re.IGNORECASE),\n                            (\"Try to add user into dialout or uucp group.\"),\n                        ],\n                    )\n    \n                hint_msg = \"\"\n                for port_issue in port_issues:\n                    if port_issue[0].search(str(e)):\n                        hint_msg = f\"\\nHint: {port_issue[1]}\\n\"\n                        break\n    \n>               raise FatalError(\n                    f\"Could not open {port}, the port is busy or doesn't exist.\"\n                    f\"\\n({e})\\n\"\n                    f\"{hint_msg}\"\n                )\nE               esptool.util.FatalError: Could not open /dev/ttyUSB0, the port is busy or doesn't exist.\nE               ([Errno 6] could not open port /dev/ttyUSB0: [Errno 6] No such device or address: '/dev/ttyUSB0')\n\n/usr/local/lib/python3.12/site-packages/esptool/loader.py:389: FatalError"
    },
    {
      "path": "hardware.missing_runner",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/wifi/esp32/wifi1.xml\n./artifacts/test-results-hw/validation/wifi/esp32s2/wifi1.xml\n./artifacts/test-results-hw/validation/wifi/esp32s3/wifi1.xml",
      "title": "All 3 runs with error: wifi1 (hardware.missing_runner)",
      "raw_details": "No available runner matches required tags: esp32s3 wifi_router (chip=esp32s3)\nThe hardware test could not be scheduled because no runner with the required tag combination is online/available."
    },
    {
      "path": "hardware.missing_runner",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/wifi/esp32c3/wifi.xml\n./artifacts/test-results-hw/validation/wifi/esp32c6/wifi.xml",
      "title": "All 2 runs with error: wifi (hardware.missing_runner)",
      "raw_details": "No available runner matches required tags: esp32c3 wifi_router (chip=esp32c3)\nThe hardware test could not be scheduled because no runner with the required tag combination is online/available."
    },
    {
      "path": "hardware.missing_runner",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "failure",
      "message": "./artifacts/test-results-hw/validation/wifi/esp32/wifi0.xml\n./artifacts/test-results-hw/validation/wifi/esp32s2/wifi0.xml\n./artifacts/test-results-hw/validation/wifi/esp32s3/wifi0.xml",
      "title": "All 3 runs with error: wifi0 (hardware.missing_runner)",
      "raw_details": "No available runner matches required tags: esp32 wifi_router (chip=esp32)\nThe hardware test could not be scheduled because no runner with the required tag combination is online/available."
    },
    {
      "path": ".github",
      "start_line": 0,
      "end_line": 0,
      "annotation_level": "notice",
      "message": "There are 54 tests, see \"Raw output\" for the full list of tests.",
      "title": "54 tests found",
      "raw_details": "auto_baudrate_test\nbasic_transmission_test\nbegin_when_running_test\nchange_baudrate_test\nchange_clock\nchange_cpu_frequency_test\nchange_pins_test\ndisabled_uart_calls_test\nenabled_uart_calls_test\nend_when_stopped_test\nhardware.missing_runner ‑ wifi\nhardware.missing_runner ‑ wifi0\nhardware.missing_runner ‑ wifi1\nhardware.missing_runner ‑ wifi2\nperformance.coremark.test_coremark ‑ test_coremark\nperformance.fibonacci.test_fibonacci ‑ test_fibonacci\nperformance.linpack_double.test_linpack_double ‑ test_linpack_double\nperformance.linpack_float.test_linpack_float ‑ test_linpack_float\nperformance.psramspeed.test_psramspeed ‑ test_psramspeed\nperformance.ramspeed.test_ramspeed ‑ test_ramspeed\nperformance.superpi.test_superpi ‑ test_superpi\nperiman_test\npsram_found\nresize_buffers_test\nrtc_run_clock\nrtc_set_time\nscan_bus\nscan_bus_with_wifi\nswap_pins\ntest_api\ntest_calloc_success\ntest_fail\ntest_malloc_fail\ntest_malloc_success\ntest_memcpy\ntest_memset_all_ones\ntest_memset_all_zeroes\ntest_memset_alternating\ntest_memset_random\ntest_pass\ntest_realloc_success\ntest_touch_errors\ntest_touch_interrtupt\ntest_touch_read\ntimer_clock_select_test\ntimer_divider_test\ntimer_interrupt_test\ntimer_read_test\nvalidation.democfg.test_democfg ‑ test_cfg\nvalidation.gpio.test_gpio ‑ test_gpio\nvalidation.hello_world.test_hello_world ‑ test_hello_world\nvalidation.nvs.test_nvs ‑ test_nvs\nvalidation.periman.test_periman ‑ test_periman\nvalidation.wifi.test_wifi ‑ test_wifi"
    }
  ],
  "check_url": "https://github.com/lucasssvaz/arduino-esp32/runs/52664086105",
  "formatted": {
    "stats": {
      "files": "186",
      "errors": [],
      "suites": "186",
      "duration": "6 359",
      "suite_details": [
        {
          "name": "validation_wokwi_esp32s3_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_uart0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_uart0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_uart0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_touch0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32h2_uart0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32c3_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_wifi2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32_timer0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_psram0",
          "tests": 8,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_i2c_master0",
          "tests": 6,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_i2c_master0",
          "tests": 6,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_touch0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_wifi1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32s3_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_wifi",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32c3_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_uart0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_timer0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_uart0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_linpack_double0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c6_wifi",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32s2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_wifi1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32c3_uart0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_wifi1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32h2_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_uart0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_nvs3",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_uart0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_touch0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_democfg0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32h2_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s3_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32p4_gpio0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_hardware_esp32p4_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_uart0",
          "tests": 11,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "performance_hardware_esp32c3_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_wifi1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32h2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32c6_i2c_master0",
          "tests": 7,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_psram0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_nvs0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_nvs2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_wifi1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32p4_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s3_wifi2",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_coremark0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_uart0",
          "tests": 10,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32c3_periman0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32h2_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_psram0",
          "tests": 8,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s3_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32s2_timer0",
          "tests": 4,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_linpack_float0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_democfg1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_hello_world0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c3_fibonacci0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c3_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32c6_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 1
        },
        {
          "name": "validation_wokwi_esp32s3_wifi1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32c6_wifi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32s2_superpi0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_wokwi_esp32s2_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32_nvs1",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32h2_ramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32s2_unity0",
          "tests": 2,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "performance_hardware_esp32p4_psramspeed0",
          "tests": 1,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        },
        {
          "name": "validation_hardware_esp32p4_touch0",
          "tests": 3,
          "skipped": 0,
          "failures": 0,
          "errors": 0
        }
      ],
      "tests": "54",
      "tests_succ": "43",
      "tests_skip": "0",
      "tests_fail": "0",
      "tests_error": "11",
      "runs": "454",
      "runs_succ": "438",
      "runs_skip": "0",
      "runs_fail": "0",
      "runs_error": "16",
      "commit": "edd79b3f4417966f12b4a5b11a4af83df623068b"
    }
  }
}